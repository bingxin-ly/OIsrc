# 0/1 背包

_此问题非常经典，且思想大于代码，故以 Markdown 的形式展现。
背包问题（Knapsack Problem）仍属于线性 DP 的范畴，但由其模型重要而特殊，自成一派。_

考虑一个问题：
> $N$ 个物品，给定他们的体积 $V_i$ 与价值 $W_i$，选定一些物品，问在总体积不超过 $M$ 的情况下的最大价值是多少。

我们依次考虑每个物品，以“已处理的物品数”为阶段，“背包已用的体积”为附加状态，设 $F[i, j]$ 表示从前 $i$ 个物品中选出了总体积为 $j$ 的物品时的最大价值和，有方程
$$
F[i][j] =
\begin{cases}
    F[i-1,j] & \text{不选第 i 个物品} \\
    F[i-1,j-V_i] + W_i \quad \text{if} \; j \ge V_i & \text{选第 i 个物品}
\end{cases}
$$
初值：$F[0,0] = 0$，其余均为负无穷；目标：$\max\limits_{0\le j \le M}\{F[N][j]\}$

```cpp
memset(f, ~0x3f, sizeof(f));
f[0][0] = 0; // Explicit is better than implicit.
for (int i = 1; i <= n; i++)
{
    for (int j = 0; j <= m; j++)
        f[i][j] = f[i - 1][j]; // 不选：从上一阶段继承来
    for (int j = v[i]; j <= m; j++)
        f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
}
```

**滚动数组**
通过方程我们发现， DP 每一阶段的转移只和上一阶段有关系，而上上阶段及之前的状态是多余的，我们可以使用 **“滚动数组”** 来降低空间开销。
我们数组的第一维只开两个，两维交替转移，这一点我们可以用奇偶性轻松做到，用位运算 `& 1` 轻松实现。然而在实际应用中需要注意的一点是由于交替转移时只有这两维，我们要保证无论 DP 到哪个阶段时这一维数组还是新的，没有被用过，才能保证得到正确的数值。
这里的情况为如果不选的话，就相当于复制了上阶段的状态，可以直接赋值，所以没有显式的清空操作，一般情况要在这一维转移完成后将上一维恢复（可参见前一节例题：Mobile Service，其中 `f[(i - 1) & 1][x][y] = 0x3f3f3f3f;` 便是这一步操作）
~~这里应该有图，但是我们毕竟搞的是想象学竞赛，所以就不放了，大家顺便也练习一下自己的想象能力。~~

```cpp
int f[2][M];
memset(f, ~0x3f, sizeof(f));
f[0][0] = 0;
for (int i = 1; i <= n; i++)
{
    for (int j = 0; j <= m; j++)
        f[i & 1][j] = f[(i - 1) & 1][j];
    for (int j = v[i]; j <= m; j++)
        f[i & 1][j] = max(f[i & 1][j],
                          f[(i - 1) & 1][j - v[i]] + w[i]);
}
int ans = 0;
for (int j = 0; j <= m ;j++)
    ans = max(ans, f[n & 1][j]);
```

**只用一维**
进一步分析，容易发现，如果我们只是从 $F[i - 1][]$ 到 $F[i][]$ 进行拷贝，当前状态 $i$ 我们也不关心，提示我们可以进一步省略 $F$ 数组的第一维

```cpp
int f[M];
f[0] = 0;
for (int i = 1; i <= n; i++)
    for (int j = m; j >= v[i]; j--)
        f[j] = max(f[j], f[j - v[i]] + w[i]);
int ans = 0;
for (int j = 0; j <= m; j++)
    ans = max(ans, f[j]);
```

然而再这样编码的情况下必须保证在这一维内的阶段转移顺序是正确的, 比如我们这里就用了倒序循环：
当循环到 $j$ 时：

1. $F$ 数组的后半部分 $F[j \sim M]$ 处于“第 $i$ 个阶段”，也就是已经考虑过放入第 $j$ 个物品
2. 前半部分 $F[0 \sim j - 1]$ 处于“第 $i - 1$ 个阶段”，也就是还没有第 $i$ 个物品更新

随着 $j$ 不断减小，也就是不断用第 $i - 1$ 个阶段更新第 $i$ 个阶段，进而保证第 $i$ 个物品只会被用一次。
而如果采用正序循环，一个物品可能会被更新多次，在第 $i$ 阶段中重复转移，违背了线性 DP 的原则。所以，在滚动数组到只有一维时，循环顺序是非常重要的。
