# P5694 计数DP入门

## 题意

给定 $L1$ 个 `{}`，$L2$ 个 `[]`，$L3$ 个 `()`，让你使用它们组成一些括号序列，规定：

- 在纵向上，大、中、小括号只能依次嵌套，如 `{[()]}`；
- 在横向上，小的括号序列能任意拼接成更大的括号序列，如 `[](){}`；
- 一个括号序列的深度定义为纵向嵌套中嵌套的最大层数。

问合法的深度为 $D$ 的括号序列有多少种？

## 解法：计数 DP

根据题意，我们思考怎么把原问题划分成规模更小的**子问题**，其中，有 `{}`、`[]`、`()` 和 `+`（连接）四种方式，我们可以从这里入手。同时，注意到横向上的拼接点可能有多种，需要避免重复计数。

我们这里用一种计数 DP 常用的处理方法，划分子问题时，将一个大的问题只划分为构成“第一段”的部分和剩下的部分，作为子问题，放在这题我们就设想对于 `[S]{[SS](SSS)}`，我们选取 `[S]` 作为它的第一段序列，其中不能有任何其他在横向上的拼接。这样，我们保证了每个横向拼接只在第一个位置处断开，避免重复。

划分完之后，我们考虑 DP **状态**的设计，在构造序列的过程中，有几个量是需要考虑的：当前的**深度**，当前大、中、小括号各自的**数量**。我们可以有一个初步想法就是设 $f_{p, i, j, k}$ 表示深度为 $p$ 时，分别使用了 $i, j, k$ 个不同括号时的方案数，在转移时我们考虑枚举第一段的外层括号以及第一段的深度、两端各自的括号数即可。

这样做未免有些麻烦，我们考虑发现，无论我们处于转移时的哪个阶段，都需要考虑深度一直从 $0$ 到 $p$ 的所有情况，每一个都需要来这样一个 for。那我们就可以简化一下状态的定义，重新设为 $f_{p, i, j, k}$ 表示深度 **不超过** $p$ 时，分别使用了 $i, j, k$ 个不同括号时的方案数。这样我们在计算时，加上去就可以了；转移时，也不用 for 循环枚举，都很方便。

现在 DP 状态的转移即为：

1. 考虑第一段的最外层括号
2. 枚举第一段的括号构成

如果最外层是大括号，那么这三种括号都是可以的，我们枚举第一段的括号，有转移方程：
$$f_{p, i, j, k} = \sum_{u = 1}^i \sum_{v = 0}^j \sum_{w = 0}^k f_{p - 1, u - 1, v, w} \times f_{p, i - u, j - v, k - w}$$
如果最外层是中括号，那么相应的，第一段中就不能有大括号，少一个 $\sum$，有转移方程：
$$f_{p, i, j, k} = \sum_{v = 1}^j \sum_{w = 0}^k f_{p - 1, 0, v - 1, w} \times f_{p, i, j - v, k - w}$$
如果最外层是小括号……请读者自行推导完成。

初值：$f_{i, 0, 0, 0} = 1$，目标：$f_{D, L1, L2, L3} - f_{D - 1, L1, L2, L3}$，复杂度：$O(DL^6)$。

如果感觉完全理解了，本题转移方程较长，建议自己在纸上自行独立推导一遍；如果没有完全理解，可以重新看一遍题，同时这里附上代码，帮助辅助理解，Code：

```cpp
#include <bits/stdc++.h>
using namespace std;

constexpr int MOD = 11380;
int L1, L2, L3, D;
int f[35][15][15][15];
signed main()
{
    ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
    cin >> L1 >> L2 >> L3 >> D;
    for (int i = 0; i <= D; i++)
        f[i][0][0][0] = 1;
    for (int p = 1; p <= D; p++)
        for (int i = 0; i <= L1; i++)
            for (int j = 0; j <= L2; j++)
                for (int k = 0; k <= L3; k++)
                {
                    if (i) // 最外层括号是 {}
                        for (int u = 1; u <= i; u++)
                            for (int v = 0; v <= j; v++)
                                for (int w = 0; w <= k; w++)
                                    (f[p][i][j][k] += f[p - 1][u - 1][v][w] * f[p][i - u][j - v][k - w] % MOD) %= MOD;
                    if (j) // 最外层括号是 []
                        for (int v = 1; v <= j; v++)
                            for (int w = 0; w <= k; w++)
                                (f[p][i][j][k] += f[p - 1][0][v - 1][w] * f[p][i][j - v][k - w] % MOD) %= MOD;
                    if (k) // 最外层括号是 ()
                        for (int w = 1; w <= k; w++)
                            (f[p][i][j][k] += f[p - 1][0][0][w - 1] * f[p][i][j][k - w]) %= MOD;
                }
    // Tips: 如果深度为 0，就不需要再减一遍了，需要一个小特判
    if (D)
        cout << (f[D][L1][L2][L3] - f[D - 1][L1][L2][L3] + MOD) % MOD;
    else
        cout << f[D][L1][L2][L3];
    return 0;
}
```
