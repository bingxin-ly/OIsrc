# AcWing 315. 旅行

## 简要题意

给定两个串 A、B，求出两个串的最长公共子序列（LCS），**按字典序输出所有可能方案**。[输入输出样例](https://www.acwing.com/problem/content/317/)
（$1 \le |A|、|B| \le 80$，仅含小写英文字母）

## 思路转化

由于这题要求输出 LCS 方案，所以实际上已经完全变成另一道题了，先把我们脑子里那坨求 LCS 长度的没有水平的东西扔掉。

> Q: 为什么我们朴素的求 LCS 长度加决策记录不行？
  A: 首先这个 LCS 有多种匹配的方案，例如 `caba` 与 `ca`这两个串有两种不同的匹配位置，但实际上只有一种方案。为了去重，你不仅需要知道每个位置是否一样，你还需要知道这个位置上是什么。转移状态时 $f(i, j)$ 只知道长度是几，并不能告诉你上一个确切的匹配位置（别说多个了）。如果我们像 LCS 一样只记录长度，每次扩展时还需要枚举 A、B 串，找到上一个相同的位置，而这是 $O(N^2M^2)$ 的。

这一切其实在说明一个问题，**原本的状态设计已经不足以支撑我们现在的最优子结构**了。在确定两个相等的位置后，我们要快速地求出**上一个**两字符串可以相等的位置，然后这个其实就可以直接预处理出来，然后再 DP 转移。

> Q: 字典序怎么保证？
  A: reverse 倒序处理，枚举时从 a~z。
  
然后在枚举两个串的过程中，不用 $f(i, j) = f(i - 1, j - 1) + 1$，因为我们已经知道了上一个相等的位置，只需要 $f(pa, pb) + 1 和 f(i, j)$ 做比较，比较的时候枚举出一个个字符即可，最后 dfs 打印出所有的可能，因为我们倒序过，所以这样正好是正的。

> 另外末尾可以人为地加一个特殊字符，保证在结尾处两字符串匹配，方便回溯。
