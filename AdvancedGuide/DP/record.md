> 你不会的题，很可能就是 DP

_8.24 Jimmy 所署乱吾学之计，无以安为题，遂治旧学。_

先决条件：问题与状态空间、递归与递推、~~搜索~~

---

## 0x50 总论

碎碎念：常常，一个大的问题是很难解决的，考虑类似于数学归纳法，通过问题的可划分性以及子问题之间的相似性来进行归纳，使它更易于解决；动态规划也不例外。通过将问题划分为几个 **重叠的子问题**，这些求解子问题的过程就是 **阶段**，并通过这些子问题的解得出原问题的解，正是动态规划降复杂度的奥秘所在。

这一性质就被称作问题的 **最优子结构**，实际上，我们对于每个子问题同时也只保留这些信息，作为当前子问题的 **状态**。这就要求这些代表信息应该具有可重复的求解过程，并能够导出后续阶段的代表信息。同时，为了使问题的求解有序，我们通常采用固定的顺序，将问题在某些维度上划分，将阶段在这些维度上的增长看成整个问题求解的顺序，而具体地，如何将小问题扩展为大问题则是 **决策**，动态规划每一步的转移都对应着一步决策，且最好需要保证问题中我们当前的决策选择不会对后面的选择造成影响，也就是 **无后效性**。

“**阶段**”“**状态**”和“**决策**”是构成动态规划的三要素；而“_重叠子问题_”“_最优子结构_”和“_无后效性_”是问题能用动态规划求解的三个基本条件。可以看出，这三条直接是有内在联系和一一对应的。

## 0x51 线性 DP

DP 的转移沿着各个维度线性增长。

### AcWing 271. Mr.Young's Picture Permutations

> 有 $N$ 个学生合影，站成左端对齐的 $k$ 排，每排分别有 $N_1, N_2, \ldots, N_k$ 个人，$(N_1 \ge N_2 \ge \ldots \ge N_k)$，第 $1$ 排站在最后边，第 $k$ 排站在最前边。学生的身高互不相同，把他们从高到底依次标记为 $1, 2, \ldots, N$。在合影时要求每一排从左到右身高递减，每一列从后到前身高也递减。问一共有多少种安排合影位置的方案？$N \le 30, k \le 5$。

我们直接从高到低考虑每个人都位置，这样就能直接满足方案中单调的要求。在本题中，要理解的一点便是：**轮廓也可以作为状态**。当题目中要求的高低次序已经满足，我们只需要考虑把人放在这的这个位置合不合法即可。这样，我们状态的表示就与之前已经站好的人无关，而一个 $k$ 元组 $(a_1, a_2, a_3, \ldots, a_k)$ 描绘的轮廓内的合影方案总数就足以构成一个子问题，从而在人数上转移。

$$
\begin{array}{l}
    F[a_1 + 1, a_2, a_3, a_4, a_5] \operatorname{+=} F[a_1, a_2, a_3, a_4, a_5] & a_1 < N_1 \\
    F[a_1, a_2 + 1, a_3, a_4, a_5] \operatorname{+=} F[a_1, a_2, a_3, a_4, a_5] & a_2 < N_2 \wedge a_1 > a_2 \\
    F[a_1, a_2, a_3 + 1, a_4, a_5] \operatorname{+=} F[a_1, a_2, a_3, a_4, a_5] & a_3 < N_3 \wedge a_2 > a_3 \\
    F[a_1, a_2, a_3, a_4 + 1, a_5] \operatorname{+=} F[a_1, a_2, a_3, a_4, a_5] & a_4 < N_4 \wedge a_3 > a_4 \\
    F[a_1, a_2, a_3, a_4, a_5 + 1] \operatorname{+=} F[a_1, a_2, a_3, a_4, a_5] & a_5 < N_5 \wedge a_4 > a_5
\end{array}
$$

### AcWing 272. LCIS

> 对于两个数列 $A$ 和 $B$，如果它们都包含一段位置不一定连续的数，且数值是严格递增的，那么称这一段数是两个数列的公共上升子序列，求所有的公共上升子序列中最长的公共上升子序列的长度。$|A|, |B| \le 3000$

LCS 问题需要知道当前考虑到了 $A, B$ 串的哪个位置，LIS 问题需要知道当前串的结尾是多少。而在实际做的时候，你一定不想 $B$ 串同时考虑求解的位置与结尾这两个状态，所以我们可以在 LIS 的基础上扩展，在已上升的子序列中，考虑公共的部分，涉及状态时将 $A$ 套到外层即可：$F[i, j]$ 表示 $A_1 \sim A_i$ 与 $B_1 \sim B_j$ 可以构成的以 $B_j$ 结尾的 LCIS 的长度（$B$ 序列 LIS，同时与 $A$ 序列 LCS）。

转移时，有：

$$
F[i, j] =
\begin{cases}
    F[i - 1, j] & A_i \neq B_j \\
    \max\limits_{0 \le k < j, B_k < B_j}\{F[i - 1, k]\} + 1 & A_i = B_j
\end{cases}
$$

朴素方法使用三重循环解决即可。但在转移过程中，我们关注决策集合，（我们把满足 $0 \le k < j, B_k < B_j$ 的 $k$ 构成的集合称为 $F[i, j]$ 进行状态转移时的决策集合，记为 $S(i, j)$。注意到，$j$ 从 $1$ 变为 $m$ 的过程中，整数 $j$ 可能进入决策集合仅当 $B_j < A_i$，而已经在决策集合中的数一定不会删除，对于“决策集合中的元素只增多不减少”的情景，我们用一个数据结构来维护这个最大值，即可避免重复扫描，把转移的复杂度降低一个量级。

### AcWing 273. Making the Grade

> 给定长度为 $N$ 的序列 $A$，构造一个长度为 $N$ 的序列 $B$，满足：
>
> 1. $B$ 非严格单调，即 $B_1 \le B_2 \le \ldots \le B_N$ 或 $B_1 \ge B_2 \ge \ldots \ge B_N$。
> 2. 最小化 $S = \sum^N_{i = 1}|A_i − B_i|$。
>
> 求出这个最小值 $S$。

考虑 $N^2$ 做法，其瓶颈在于题目并不允许我们记录当前结尾选了什么数，而 LIS 问题之所以不用考虑这个问题就是在于“子序列”这个东西表明选的数一定在 $A$ 现过，而我们要求的是代价最小，可以贪心而大胆地想一下构造时我们所用到的数都是在 $A$ 过的。

**用贪心的性质来简化动归的设计**
我们按阶段的划分进行数学归纳，就是一个货仓选址。于是有 $f[i][j]$ 表示完成前 $i$ 个的构造，$B_i = j$ 的最小值。

$$
F[i, j] = \min\limits_{0 \le k \le j}\{F[i - 1][k] + |A_i - j|\}
$$

$j$ 在扩展时，显然只会多出来一个点，所以可以变量维护一下 $O(1)$ 转移

### AcWing 274. Mobile Service

> 一个公司有三个移动服务员，最初分别在位置 $1, 2, 3$ 处。
> 如果某个位置（用一个整数表示）有一个请求，那么公司必须指派某名员工赶到那个地方去。某一时刻只有一个员工能移动，且不允许在同样的位置出现两个员工。从 $p$ 到 $q$ 移动一个员工，需要花费 $c(p, q)$。这个函数不一定对称，但保证 $c(p, p) = 0$。
> 给出 $N$ 个请求，请求发生的位置分别为 $p_1 \sim p_N$。公司必须按顺序依次满足所有请求，且过程中不能去其他额外的位置，目标是最小化公司花费，请你帮忙计算这个最小花费。$N \le 1000$，位置是 $1 \sim 2000$ 的整数。

这题的状态和转移非常好想：记录三个服务员的位置 $(x, y, z)$，然后分阶段分别让这三个服务员去服务第 $i + 1$ 个请求，代价取最小值。问题是：这个状态储存和转移的量非常大，细想之后可以发现：服务完第 $q_i$ 个请求后，一定有且仅有一个服务员在第 $q_i$ 个请求的位置，所以我们记录三个人其实是多了，故我们只需记录两个人的位置，剩下那一个人可以推导得出，就像线性代数的线无关组，减少了多余的状态和转移。

$$
\begin{array}{l}
    F[i + 1, x, y] = \min(F[i + 1, x, y], F[i, x, y] + c(p_i, p_{i + 1})) \\
    F[i + 1, p_i, y] = \min(F[i + 1, p_i, y], F[i, x, y] + c(x, p_{i + 1})) \\
    F[i + 1, x, p_i] = \min(F[i + 1, x, p_i], F[i, x, y] + c(y, p_{i + 1}))
\end{array}
$$

两点启发：

1. 求解线性 DP 问题，一般先确定“阶段”。若“阶段”不足以表示一个状态，则可以把所需的附加信息也作为状态的维度。无后效性由“阶段”保证。
2. 确定 DP 状态时，要选择最小的能够覆盖整个状态空间的“维度集合”。
