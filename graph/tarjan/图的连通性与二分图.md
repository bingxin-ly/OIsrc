# 图的连通性与二分图补充

_20230319_

- [tarjan 算法与图的连通性](#图连通性)

  - [有向图强连通分量(SCC)](#有向图强连通分量)
  - [无向图双连通分量(割点，桥，e-DCC，v-DCC)](#无向图双连通分量)

- [二分图](#二分图其他概念补充)

  - 最小点覆盖
  - 最大独立集

- 知识点 + 经典题 + 一点进阶题

## 图连通性

参考资料：[oi-wiki](https://oi-wiki.org//graph/scc/)，[jiazp](https://www.cnblogs.com/JiaZP/p/13373798.html)

### 搜索树

- 搜索树：对图 DFS 得到的生成树。是一种具有相对简单结构的生成树，一些构造题中也经常用到。

  - 有向图搜索树：只包含**树边**，**前向边**(forward edge)，**返祖边**(back edge)和**横叉边**(cross edge)；
  - 无向图搜索树：只包含 **前向边** 和 **后向边** 。

有向图搜索树

[![](https://oi-wiki.org/graph/images/dfs-tree.svg)](https://oi-wiki.org/graph/scc/#dfs-%E7%94%9F%E6%88%90%E6%A0%91)

无向图搜索树

[<img src="https://oi-wiki.org/graph/images/bcc-1.svg" width="200">](https://oi-wiki.org/graph/bcc/#dfs-%E6%89%BE%E6%A1%A5%E5%B9%B6%E5%88%A4%E6%96%AD%E8%BE%B9%E5%8F%8C%E8%BF%9E%E9%80%9A)

### 有向图强连通分量

**强连通图** ：如果对于图中的任意两点 $u,v$，都存在从 $u$ 到 $v$ 的路径，那么这张图称为一张强连通图。
**强连通分量** (Strongly Connected Components, SCC)：极大强连通子图。
_弱连通图_：将有向边视为无向边时连通的图称为弱连通图。
![MablC.png](https://i.328888.xyz/2023/03/19/MablC.png)

强连通图（分量）具有一些有意思的性质：

> 环一定是强连通图
> **强连通图中每个点都一定在至少一个简单环上**
> （但可能存在两点不在一个公共简单环上）
> 强连通性质具有传递性（u 与 v 强连通，v 与 w 强连通，则 u 与 w 强连通）
> **每个点都属于恰好一个 SCC**

![MajgP.png](https://i.328888.xyz/2023/03/19/MajgP.png)

### 有向图 tarjan 算法

目标：找到有向图中的所有强连通分量。
基本原理：在每个 SCC 的“最顶部”出处理该 SCC。
对图进行 DFS，同时标记：
`dfn`：dfs 序，即 $x$ 是第几个被 DFS 到的点；
`low`：搜索树中 $x$ 的子树里面走一条非树边（返祖边）所能达到的最小的 `dfn` （初始为`dfn[x]` ）
同时维护还没被归为 SCC 中的点的栈（以及相关信息）
判断 $x$ 是否是其所在 SCC 中 dfs 序最小的点： `low[x] == dfn[x]` 。成立则不断弹栈记录。

有向图 tarjan 实现：

```cpp
int dcnt, dfn[N], low[N];
int stk[N], top;
int ccnt, col[N], vis[N];
void tarjan(int cur)
{
    dfn[cur] = low[cur] = ++dcnt;
    stk[++top] = cur;
    vis[cur] = true;
    for (int i = head[cur]; i; i = e[i].nxt)
    {
        int to = e[i].to;
        if (!dfn[to])
        {
            tarjan(to);
            low[cur] = min(low[cur], low[to]);
        }
        else if (vis[to])
            low[cur] = min(low[cur], dfn[to]);
    }
    if (low[cur] == dfn[cur])
    {
        int tmp;
        ccnt++;
        do
        {
            tmp = stk[top--];
            col[tmp] = ccnt;
            vis[tmp] = false;
        } while (tmp != cur);
    }
}
...
for (int i = 1; i <= n; ++i)
        if (!dfn[i])
            tarjan(i);
```

### 有向图强连通分量缩点

将同一个 SCC 缩成一个点，有向图将简化为 **有向无环图** (Directed Acyclic Graph, DAG)。

```cpp
for (int i = 1; i <= n; ++i)
{
    for (int j = head[i]; j; j = e[j].nxt)
    {
        int to = e[j].to;
        if (col[i] != col[to])
            aded(col[i], col[to]);
    }
}
```

有向无环图就可以进行拓扑排序等操作

### 经典题：[【模板】缩点](https://www.luogu.com.cn/problem/P3387)

> 给定一个 n 个点 m 条边的有向图，点有点权，求最长路长度。
> 一条路径的长度定义为路径上经过的点的点权和。多次经过只算一次。
> $n ≤ 10^4, m ≤ 10^5$

### 【模板】缩点 题解

- 贪心：到达一点必定走完其 SCC 中的所有点。
- 缩点后跑 DAG 最长路即可。（拓扑 DP）
- $O ( n + m )$
  [代码实现](v-shrink.cpp)

### 经典题：[校园网络](https://www.luogu.com.cn/problem/P2812)

（看啥都感觉是经典题）

> 给定一张有向图。问：
>
> 1.  至少需要选择几个点才能（合起来）可以到达所有点；
> 2.  至少需要添加多少条边才能让每个点能够到达其他所有点。
>     $n ≤ 10 , 000 ; m ≤ 50 , 000$

（觉得太简单可以再做做 [软件安装](https://www.luogu.com.cn/problem/P2515)，或者再看看上周讲的 [Grass Cownoisseur G](https://www.luogu.com.cn/problem/P3119)）

### 校园网络 题解

显然缩点不影响答案，因此先缩点。然后 1 问答案就是 0 入度点数量， 2 问答案就是
max { 0 入度点数量,1 入度点数量 }

### 无向图双连通分量

- 割点/割顶：如果删掉 $x$ 会多出来几个连通块，则称 $x$ 为一个 **割点** 或 **割顶** (cut vertex)。
- 不存在割点的无向连通图称为 **点双连通图** 。极大点双连通子图称为 **点双连通分量**(biconnected component)
- 割边/桥：如果删掉边 $e_{u,v}$ 会多出来几个连通块，则称 $e_{u,v}$ 为一条 **割边** 或 **桥**(bridge)。
- 不存在割边的无向连通图称为 **边双连通图** 。极大边双连通子图称为 **边双连通分量** (2-edge-connected component)
  ![](https://oi-wiki.org/graph/images/bcc-0.svg)

### 割点与点双连通分量

一些性质：

- n ≥ 3 的边双连通图中，每个点都在一个简单环中。

- 一张图是点双连通图，当且仅当图的顶点数不超过 2 ，或者图的任意两个点都在同一个简单环（圆圈）中。

- 割点会在多个点双中，其余点只在一个点双中。

### tarjan 算法求割点

模板题：[【模板】割点（割顶）](https://www.luogu.com.cn/problem/P3388)
目标：找到无向图的所有割点。
基本原理：割掉后会分裂成多个连通块。
对图进行 DFS，同时标记：
`dfn` ：dfs 序，即 是第几个被 DFS 到的点；
`low` ：搜索树中 的子树里面走若干条树边或非树边所能达到的最小的 `dfn` （初始为`dfn[x]` ）
判断 的 子树是否不能到达 以上（被 x 截住）： `low[y] >= dfn[x]` 。成立则让 cnt + 1。最后初始点 cnt >= 2 则是割点，其余点 cnt >= 1 则是割点。

tarjan 求割点实现：

```cpp
void tarjan(int cur)
{
    dfn[cur] = low[cur] = ++dcnt;
    int cnt = 0;
    for (int i = head[cur]; i; i = e[i].nxt)
    {
        int to = e[i].to;
        if (!dfn[to])
        {
            tarjan(to), low[cur] = min(low[cur], low[to]);
            if (low[to] >= dfn[cur])
                ++cnt;
        }
        else
            low[cur] = min(low[cur], dfn[to]);
    }
    if (cur == root && cnt >= 2)
        cutnode[++ccnt] = cur;
    if (cur != root && cnt >= 1)
        cutnode[++ccnt] = cur;
}
...
for (int i = 1; i <= n; ++i)
        if (!dfn[i])
            root = i, tarjan(i);
```

### 求点双和缩点

（随便编一编就好）

求点双：tarjan 的时候维护一个栈。无论是否是根，在遇到 `low[to] >= dfn[cur]` 时弹栈一直弹到 to，然后弹出的所有点再加上 cur 即为一个点双连通分量。
缩点：注意把割点复制一份。缩完点后会变成森林，每个点的邻居都与自己性质不同。
![](https://i.328888.xyz/2023/03/19/Ma1YQ.png)

实现：（圆方树好）

```cpp
void tarjan(int cur)
{
    stk[++top] = cur;
    dfn[cur] = low[cur] = ++dcnt;
    int cnt = 0;
    for (int i = head[cur]; i; i = e[i].nxt)
    {
        int to = e[i].to;
        if (!dfn[to])
        {
            tarjan(to);
            low[cur] = min(low[cur], low[to]);
            if (low[to] >= dfn[cur])
            {
                cnt++;
                if (cur != rt || cnt > 1)
                    iscut[cur] = true;
                int tmp;
                dcc_tot++;
                do
                {
                    tmp = stk[top--];
                    dcc[dcc_tot].push_back(tmp);
                } while (tmp != to);
                dcc[dcc_tot].push_back(cur);
            }
        }
        else
        {
            low[cur] = min(low[cur], dfn[to]);
        }
    }
}
inline void rebuild()
{
    int ntot = n;
    for (int i = 1; i <= n; ++i)
    {
        if (iscut[i])
            newid[i] = ++ntot;
    }
    for (int i = 1; i <= dcc_tot; ++i)
    {
        for (int j = 0; j < (int)dcc[i].size(); ++j)
        {
            int cur = dcc[i][j];
            if (iscut[cur])
            {
                aded(nwid[cur], i);
                aded(i, nwid[cur]);
            }
            else
            {
                col[cur] = i;
            }
        }
    }
}
```

### 点双内部重建\*

判断每个点双内部有哪些边
（留做习题答案略）可以参考[我的博客](https://www.cnblogs.com/JiaZP/p/13373798.html)

原题是 [Cycling City](https://codeforces.com/contest/521/problem/E)，但是模拟赛搬运题[城市骑行](https://www.luogu.com.cn/problem/T162381?contestId%3D39329)数据更强。（并非此题难点，不知道有没有其他提交地点）

### 桥与边双连通分量

一些性质：

- 桥一定是搜索树上的边

- 环上的边都不是桥

- 一张无向连通图是边双连通图，当且仅当对于图中每条边，都在至少一个简单环上

- 边双缩点成森林

### tarjan 求割边及边双

对图进行 DFS，同时标记：

`dfn`：dfs 序，即 是第几个被 DFS 到的点；
`low`：搜索树中 的子树里面走若干条树边或非树边所能达到的最小的 `dfn` （初始为`dfn[x]` ）
判断 $x$ 的 $y$ 子树是否不能到达 $y$ 以上（被 $e_{x,y}$ 截住）： `low[y] > dfn[x]` 。成立则 $e_{x,y}$ 是割边。注意不要把 的 dfn 拿过来更新 `low[y]` （见代码）
如何求边双：留做习题答案略

tarjan 求割边实现

```cpp
//(initial)ecnt = 1
void tarjan(int cur, int ine)
{
    dfn[cur] = low[cur] = ++dtot;
    for (int i = head[cur]; i; i = e[i].nxt)
    {
        int to = e[i].to;
        if (!dfn[to])
        {
            tarjan(to, i);
            low[cur] = min(low[cur], low[to]);
            if (low[to] > dfn[cur])
                iscut[i] = iscur[i ^ 1] = true;
        }
        else if (i != ine ^ 1)
            low[cur] = min(low[cur], dfn[to]);
    }
}
```

### 经典题型：无向图必经点必经边

求两点 u , v 之间的必经点和必经边，只需要找到缩点后路径上的割点和割边即可。必经

点注意特判下起点终点。

经典题：[道路相遇](https://www.luogu.com.cn/problem/P4320)（必经点）

思考题\*：如何求有向图必经点必经边？

### 经典题：【GDOI2015】水题

（GMOJ 上的题，估计不让交）

> n 个点， m 条边无向图， q 次询问，每次问 i 号边删去后会有多少点对互不可达。
> n <= 1 e 5 , m <= 1 e 6 , q <= 8 e 5

### 水题 题解

- 一条边不删也有不可达点对，需要预处理。

- 删桥时答案增加 两边大小之积

- 缩点 DFS

### 经典题：[骑士](https://www.luogu.com.cn/problem/P2607)（删减版）

> 给定一个基环树森林，找出里面的所有的环。
> （有能力可以做做原题，是一道经典的基环树 DP 题）
> $n ≤ 10^6$

### 骑士（删减版） 题解

经典找环方法：DFS 找环(deprecated) / tarjan 边双 / 拓扑找环

### 进阶题：[KNIGHTS - Knights of the Round Table](https://www.luogu.com.cn/problem/SP2878)\*

> n 个点 m 条边的简单无向图。问有多少点不在任一奇环（无重点重边）上。
> $n ≤ 1000$

### KNIGHTS - Knights of the Round Table 题解

- 奇环上不能有重点：点双以外的点都不用考虑。

- 可以证明：如果点双内存在奇环，则点双内任一点都在至少一个奇环上。（找到奇环后，由于点双性质任意两个点都在至少同一个环上，因此奇环外的点一定会与奇环上的点以环的形式连接，出现环套环的现象。因此那一个环有两种形态，必定是一种奇环一种偶环）。

- 黑白染色判断是否有奇环。

### 双连通分量其他经典题进阶题

经典题：

[BLO-Blockade](https://www.luogu.com.cn/problem/P3469)
[Traffic Real Time Query System](https://www.luogu.com.cn/problem/UVA1464)
进阶题：
[矿场搭建](https://www.luogu.com.cn/problem/P3225)
[Redundant Paths G](https://www.luogu.com.cn/problem/P2860)
[Cycling City](https://codeforces.com/contest/521/problem/E)(very hard)

## 二分图其他概念补充

- （点）覆盖：点集 $V$ 使得二分图的每条边都至少有一个端点在 $V$ 中

- 独立集：点集 $V$ 使得二分图的每条边最多有一个端点在 $V$ 中

- 二分图最小点覆盖 = 最大匹配，读者自证不难 x（网上有构造证明，学完网络流最小割以后可以更直观地理解证明）
- 二分图最大独立集 = n - 最小点覆盖，其中 n 表示二分图总点数。自证不难（有很明显的对称性）

### 经典题：Royal guards\*

（经典归经典，但太超前了）

> m 行 n 列的一个矩形，被分为 m × n
> 个方格。一些方格是墙，而另一些是空地。
> 国王设了一些陷阱，每个陷阱占据一块空地。（如图）
> 你需要放置若干守卫，每个守卫占据一个方格，要求守卫之间不能相互看到（同一连续的行或同一连续的列）求最多能放几个守卫。输出方案。
> $m , n ≤ 200$

### Royal guards 题解

- 把连续的行/列当作点，格子当作边，问题转化为求二分图最大匹配。

### 经典题：[Asteroids](http://poj.org/problem?id%3D3041)\*

> 一个 n × n 矩阵的某些位置有小行星（共 K 个），一次可以炸掉一行或一列。
> 求最少要用多少炸弹。
> $n ≤ 500 , K ≤ 10 , 000$

### Asteroids 题解

（和上一题类似）

- 把行/列当作点，小行星当作边，问题转化为求二分图最小点覆盖。
